/* eslint-disable @typescript-eslint/camelcase */
import { verifyClaimSignals, getMerkleRoot } from "./crypto";

describe("verifyClaimSignals", () => {
  it("should verify valid claim", async () => {
    const verified = await verifyClaimSignals({
      proof: {
        snarkProof: {
          pi_a: [
            13908401297731209350990243002406841263053848046825583708571499746420697221945n,
            12591924947468168441754391022285210181947837861025576627226809465083170896782n,
            1n
          ],
          pi_b: [
            [
              7960116499891715989460481216354946503757496108100570772935628047952284918304n,
              17558363581491924332441442249064994499655504584405379407442125316782016154069n
            ],
            [
              2286277223599569789341010820301492166536446276354485076046350782090178809795n,
              10905859947085558816246665535817659692466412028893026871520263428087538670257n
            ],
            [1n, 0n]
          ],
          pi_c: [
            3438676002949292391849879048890161888148638997642329652059337242035010197534n,
            7233162743788984868555967919445946117589738243851202211789969393333831685039n,
            1n
          ]
        },
        merkleRoot: "399206868162372987582260884354434457525320575633864274222465898985733022407"
      },
      nullifier: "1305356353523040630876057258703884545463594833082370164470488680209172198793",
      identityGroup: "NOT_CHECKED",
      externalNullifier: "EXTERNAL_NULLIFIER",
      message: "TEST MESSAGE"
    });
    expect(verified).toBe(true);
  });

  it("should not verify invalid claim", async () => {
    const verified = await verifyClaimSignals({
      proof: {
        snarkProof: {
          pi_a: [
            13908401297731209350990243002406841263053848046825583708571499746420697221945n,
            12591924947468168441754391022285210181947837861025576627226809465083170896782n,
            1n
          ],
          pi_b: [
            [
              7960116499891715989460481216354946503757496108100570772935628047952284918304n,
              17558363581491924332441442249064994499655504584405379407442125316782016154069n
            ],
            [
              2286277223599569789341010820301492166536446276354485076046350782090178809795n,
              10905859947085558816246665535817659692466412028893026871520263428087538670257n
            ],
            [1n, 0n]
          ],
          pi_c: [
            3438676002949292391849879048890161888148638997642329652059337242035010197534n,
            7233162743788984868555967919445946117589738243851202211789969393333831685039n,
            1n
          ]
        },
        merkleRoot: "399206868162372987582260884354434457525320575633864274222465898985733022407"
      },
      nullifier: "1305356353523040630876057258703884545463594833082370164470488680209172198793",
      identityGroup: "NOT_CHECKED",
      externalNullifier: "EXTERNAL_NULLIFIER",
      message: "NOT_TEST_MESSAGE"
    });
    expect(verified).toBe(false);
  });
});

describe("getMerkleRoot", () => {
  it("should get merkle root correctly", async () => {
    const identityCommitments = [
      {
        identityGroup: "NOT_USED",
        identityCommitment: "15433425926583141295596334108520668441932269416167601126320078969474859036792"
      },
      {
        identityGroup: "NOT_USED",
        identityCommitment: "11111111111111111111111111111111111111111111111111111111111111111111111111111"
      }
    ];
    const merkleRoot = await getMerkleRoot(identityCommitments);
    expect(merkleRoot).toBe("399206868162372987582260884354434457525320575633864274222465898985733022407");
  });
});
